# 第四章 创建图片管理桌面应用



本章使用 `Vue` 的 `Electron` 插件来构建一个跨平台的（`cross-platform`）图片管理桌面应用。该应用可以快速实现本地图片的增删改查操作，同时提供了基于 `JSON` 的简易后端 `API`，可以作为原型设计时快速搭建后端服务器的小工具。



相关主题如下：

- `Vue` 组件的再理解
- 用 `Vue CLI` 插件 `Electron Builder` 创建项目
- 新增图片提交用户界面（UI）
- 新增图片展示页
- 为应用新增路由功能
- 为应用添加后端 `API` 接口



---



## 1 Vue 组件的再理解

组件（`Components`）可以包含很多内容，通过 `props` 从父组件接收数据来自定义组件行为。此外，组件也能通过计算属性及监视器（`watchers`）来监听响应式数据；还能使用 `methods` 定义方法来完成相应操作；组件的内置指令（`built-in directives`）还能用于 `DOM` 操作及数据绑定。总地来说，组件要设计得简洁高效，不应放入过多内容，包含少量的元素或子组件即可。

此外，组件也不是万能的。仅凭几个组件并且无法使用 `URL` 导航，是不可能构建任何较复杂的应用的。如果一个应用只包含组件，则只能通过组件嵌套来控制复杂度；但嵌套组件越多，内部导航也会越困难。目前大多数应用都有不同的页面，如果不引入路由机制，就不可能实现导航。

`Vue` 提供了 `Vue Router` 模块来解决导航问题。利用 `Vue Router` 可以在跳转到一个 `URL` 时渲染指定的组件，也可以通过它提供的 `router-link` 组件来实现导航。`Vue Router` 功能强大，可以实现 `URL` 与路由（`routes`）的匹配。`URL` 可以携带查询字符串及 `URL` 参数，与 `Vue Router` 相结合还可以将路由嵌套在不同的组件中。完成 `URL` 映射的组件会出现在 `Vue Router` 的 `router-view` 组件中。对嵌套路由，需要在父级路由中添加 `router-view` 组件来显示子路由。

为了导航到不同的路由，`Vue Router` 对目前几乎所有现代浏览器都内置了的 `JavaScript History API` 进行了封装。借助这个 `API`，可以轻松地返回到不同的页面、跳转到一个历史记录或期望的 `URL` 地址。`Vue Router` 还支持 `HTML5` 模式——可以使用不带哈希符号 `#` 的 `URL` 与服务端渲染的路由作区分。

此外，`Vue Router` 还支持过渡特效（`transition effects`），可以在导航到不同路由时出现。导航跳转的链接或激活状态下的链接（`active link`）也可以设置 `CSS` 样式。





## 2 了解 Vue CLI 插件 Electron Builder

### 2.1 Electron Builder 简介

使用 `Electron` 可以将 `JavaScript` 客户端 `Web` 应用转换成桌面应用。`Vue CLI` 提供的 `Electron Builder` 插件可以让开发者在一个桌面应用环境中构建 `Vue 3` 应用。`Electron` 应用本质上是运行在一个基于 `Chromium` 内核的浏览器上的 `Web` 应用，因此浏览器能实现的功能它都能实现：有限的硬件交互（调用麦克风、摄像头）、在主流操作系统的通知栏显示原生通知等。`Electron` 旨在提供一种简易的方式从 `Web` 应用来构建桌面级应用，而无须考虑底层硬件的访问。

`Electron Builder` 是从 `Vue` 应用程序创建 `Electron` 应用程序最快的方法，因为它支持一些原生代码。利用 `Electron Builder` 还可以在代码中包含原生模块（`native modules`），只需要将 `Node.js` 模块位置引入目标原生代码中即可。此外，可以包含 **环境变量** 为不同的环境构建相应的项目。由于对 `Chromium` 的支持，`Electron Builder` 也支持 `Web worker`——可用于后台任务的运行——这样当要执行长时间运行或高 `CPU` 占用的任务时，就不必阻塞浏览器主线程。所有这些功能都可以通过常规的 `Vue` 应用或修改配置来实现。

另外，也存在一些功能是 `Electron` 支持但 `Electron Builder` 不支持的，比如原生菜单功能就不支持，但跨平台创建桌面应用就是支持的——这说明插件支持的功能也是有限的，但用于功能演示已经足够了。

本章演示的是一个运行在 `Windows` 系统的关于图片管理的桌面应用，由以下部分组成：

- 用于展示所有已添加的图片的总览页；
- 添加并保存图片的表单页；
- 专用于图片存放的存储机制；
- 使用 `Vue Router` 实现页面间的导航。



### 2.2 用 Electron Builder 搭建项目

运行以下命令初始化项目：

```bash
$ mkdir vue-example-ch4-photo-manager
$ cd vue-example-ch4-photo-manager
$ npm install -g @vue/cli@next
$ vue create .
```

命令行中的初始配置项如下：

![vite app config](assets/c4-1.png)

接着添加 `Electron Builder` 插件：

```bash
$ vue add electron-builder
```

中途提示要安装的 `Electron` 版本时，选择默认的 `13.0`（实操时的 `Electron Builder` 版本为 `22.14.5`）：

![electron version](assets/c4-2.png)

命令执行成功后，`src` 目录下会新增一个 `background.js` 文件，用于显示 `Electron` 窗口。其中——

- `BrowserWindow`：该构造函数用于初始化 `Electron` 窗口大小，默认为 `800px × 600px`，可手动拖拽调整；
- `win.loadURL()` 指定应用主页，即：
  - 生产环境：为 `public/index.html` 文件；
  - 开发环境：为 `process.env.WEBPACK_DEV_SERVER_URL`；`webpack-dev-server` 仅在开发模式下才将应用程序载入内存；

- `win.webContents.openDevTools()`：用于在 `Chromium` 内核浏览器窗口打开控制台；
- `app.quit()`：根据具体的操作系统监听关闭事件来关闭该应用窗口：
  - `Windows`：监听 `message` 事件，传参为 `'graceful-exit'` 时退出应用；
  - 非 `Windows`：监听 `SIGTERM` 事件来退出应用；




同时，`package.json` 文件也新增了一些 `Electron` 命令：

- `electron:build`：用于生产环境的构建
- `electron:serve`：用于开发环境的调试

这时，运行如下命令开启开发模式：

```bash
$ npm run electron:serve
```

`Windows` 桌面将自动弹出一个 `Electron` 窗口，并尝试在这个 `Chromium` 内核的浏览器壳上添加 `Vue` 的调试工具 `Vue Devtools`（安装不成功，报错：`Vue Devtools failed to install: Error: Invalid header: Does not start with Cr24`，待解决）。

此时修改 `public/index.html` 中的 `title` 标签，改为 `Photo App`，可以看到 Electron 窗口和浏览器中的标签标题都同时更新为 `Photo App`：

![electron window](assets/c4-3.png)

由于该窗口是对 `Chromium` 内核的封装版，因此开发模式下对页面做的更改会自动同步到浏览器和 `Electron` 窗口。注意，该 `Electron` 窗口 **不可关闭**，否则相当于退出开发模式！为了便于调试，最好在 `Chrome` 浏览器（支持 `Vue Devtools`）进行调试（访问 `http://localhost:8080/` 即可）。

最后补充安装依赖 `axios`，以便后期发送 `HTTP` 请求调用后端 `API`：

```bash
$ npm install axios
```





## 3 新增图片提交用户界面（UI）

首先删除默认的 `HelloWorld` 组件及其在 `App.vue` 中的所有引用。

然后需要创建图片提交页面和主页面（用于展示所有图片）；

在此之前，先在 `.eslintrc.js` 中加入以下自定义规则（字符串使用单引号、一行的结束符自动匹配）：

```js
'prettier/prettier': [
    'error',
    {
        singleQuote: true,
        endOfLine: 'auto',
    },
],
```

所谓图片提交界面，就是供用户新增或修改图片的表单页。假设表单字段有四个：

- `name`：图片名称，字符型；
- `description`：图片描述，字符型；
- `dateTaken`：处理时间，日期型；
- `photoFile`：具体文件（`base64 URL`），字符串型；

则可以创建如下模板 `src/components/PhotoFormPage.vue`：

```vue
<template>
  <div class="form">
    <h1>{{ edit ? 'Edit' : 'Add' }} Photo</h1>
    <form @submit.prevent="submit">
      <div>
        <label for="name">Name</label>
        <input
          type="text"
          name="name"
          id="name"
          class="form-field"
          v-model="form.name"
        />
      </div>
      <div>
        <label for="description">Description</label>
        <textarea
          id="description"
          name="description"
          class="form-field"
          v-model="form.description"
        ></textarea>
      </div>
      <div>
        <label for="dateTaken">Date Taken</label>
        <input
          type="datetime-local"
          id="dateTaken"
          name="dateTaken"
          class="form-field"
          v-model="form.description"
        />
      </div>
      <div>
        <label for="photoFile">Photo</label>
        <br />
        <input type="file" name="photoFile" id="photoFile" @change="onChange" />
        <br />
        <img :src="form.photoFile" alt="" id="photo-preview" />
      </div>
      <div>
        <input type="submit" />
      </div>
    </form>
  </div>
</template>
```

接着定义 `script`。由于多个组件都会调用同一个后端 `API`，因此可以将 `API` 的根路径以一个独立模块导出。创建模块 `src/constant.js`：

```js
export const APIURL = 'http://localhost:3000';
```

然后引入该常量模块：

```vue
<script>
import axios from 'axios';
import { APIURL } from '../constant';

export default {
  name: 'PhotoForm',
  data() {
    return {
      form: {
        name: '',
        description: '',
        dateTaken: '',
        photoFile: undefined,
      },
    };
  },
  computed: {
    edit() {
      return typeof this.$route.param.id !== 'undefined';
    },
  },
  methods: {
    async submit() {
      const { name, description, dateTaken, photoFile } = this.form;
      if (!name || !description || !dateTaken || !photoFile) {
        return alert('All fields are required');
      }
      const { id } = this.$route.params;
      if (this.edit) {
        await axios.put(`${APIURL}/photos/${id}`, this.form);
      } else {
        await axios.post(`${APIURL}/photos`, this.form);
      }
      this.$router.push('/');
    },
    onChange(ev) {
      const fileReader = new FileReader();
      fileReader.readAsDataURL(ev.target.files[0]);
      fileReader.onload = () => {
        this.form.photoFile = fileReader.result;
      };
    },
  },
  async beforeMount() {
    const { id } = this.$route.params;
    if (this.edit) {
      const { data: form } = await axios.get(`${APIURL}/photos/${id}`);
      this.form = form;
    }
  },
};
</script>
```

注意以下几点：

- `axis` 接口返回的是一个 `Promise`，获取到值需要借助 `async / await` 语法；
- 修改已有图片使用 `axios.put(URL, data)`；新增使用 `axios.post(URL, data)`；
- 本例中图片是以 `base64 URL` 字符串存入后台的，适用于小型简单应用；大型应用要考虑换用文件服务器（如 `Dropbox` 或 `Amazon S3` 等），这样得到的是该文件的访问地址。两种情况下，`base64 URL` 和 `HTTP URL` 都可以作为 `src` 的属性值；
- `onChange` 事件回调逻辑中，`ev.target.files` 是一个类数组，`ev.target.files[0]` 中的 `0` 是属性名，而非索引下标；

然后是 `CSS` 样式设置。通过在 `style` 标签加关键字 `scoped` 来避免样式与其他组件相互干扰：

```vue
<style scoped>
.form {
  margin: 0 auto;
  width: 70vw;
}

.form-field {
  width: 100%;
}

#photo-preview {
  width: 200px;
}
</style>
```



## 4 新增图片主页

新增表单组件建好后，根据 `submit` 的回调逻辑，页面会跳转到主页（`this.$router.push('/')`）展示出已经添加的所有图片。因此需要新增主页组件 `src/components/HomePage.vue`：

```vue
<template>
  <div>
    <h1>Photos</h1>
    <button @click="load">Refresh</button>
    <div class="row">
      <div>Name</div>
      <div>Photo</div>
      <div>Description</div>
      <div>Actions</div>
    </div>
    <div v-for="p of photos" :key="p.id" class="row">
      <div>
        <img :src="p.photoFile" />
      </div>
      <div>{{ p.name }}</div>
      <div>{{ p.description }}</div>
      <div>
        <button @click="edit(p.id)">Edit</button>
        <button @click="deletePhoto(p.id)">Delete</button>
      </div>
    </div>
  </div>
</template>

<script>
import axios from 'axios';
import { APIURL } from '../constant';
export default {
  data() {
    return {
      photos: [],
    };
  },
  methods: {
    async load() {
      const { data: photos } = await axios.get(`${APIURL}/photos`);
      this.photos = photos;
    },
    edit(id) {
      this.$router.push({ path: `/edit-photo-form/${id}` });
    },
    async deletePhoto(id) {
      await axios.delete(`${APIURL}/photos/${id}`);
      this.load();
    },
  },
  beforeMount() {
    this.load();
  },
};
</script>

<style scoped>
.row {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.row div {
  width: 25%;
}

.row img {
  width: 100px;
}
</style>
```

注意以下几个地方：

- 第 40 行：这里用到了 `this.$router.push()` 方法来跳转到某个路由。其参数是一个包含 `path` 属性的 `JSON` 对象，`path` 的值，为目标 `URL` 与携带参数 `id` 的组合形式（`REST` 风格）；
- `HTML` 标签内是不需要插值符号 `{{}}` 的，仅在需要显示在页面的位置需要使用；
- 第 44 行：该行的作用，是将删除图片后，后端存放图片的最新结果渲染到主页面，否则前端图片数量不会立即变化；
- `CSS` 样式：采用了 `flex` 盒模型，将 `div` 以表格形式渲染到主页上。



有了图片列表展示区，还需要在主页顶部展示一个导航条，用来跳转到不同页面（如新增图片页、查询图片页等）。因此需要创建导航条组件 `src/components/NavBar.vue`：

```vue
<template>
  <nav>
    <ul>
      <li><router-link to="/">Home</router-link></li>
      <li><router-link to="/add-photo-form">Add Photo</router-link></li>
      <li><router-link to="/search">Search Photos</router-link></li>
    </ul>
  </nav>
</template>

<script>
export default {
  methods: {
    logOut() {
      localStorage.clear();
      this.$router.push('/login');
    },
  },
};
</script>

<style>
ul li {
  list-style: none;
  display: inline;
  margin-right: 10px;
}

ul {
  margin: 0 auto;
  width: 70vw;
}

a:link {
  text-decoration: none;
}
</style>
```

注意组件的模板部分，每个 `li` 元素内都有一个 `router-link` 组件。该组件是 `Vue Router` 提供的内部组件，之所以用 `router-link` 而非传统的 `a` 标签，是因为 `Vue Router` 会把 `router-link` 组件中的 `to` 属性值解析到正确的跳转路径上，一旦按 `URL` 匹配到所映射的组件就会直接加载显示。

> **勘误1**
>
> （PDF 版第 101 页）
>
> Additionally, we have a **Log Out** link to log us out of the app. 
>
> 实际上示例源码根本没有提供登录与登出的相关组件和页面导航。书中给出的两个截图（一个登录页、一个包含登出的主页面）也是错的。



## 5 新增图片查询页

为满足主页面查询图片的导航需求，需新建查询页组件。该组件的主要功能，是提供一个图片名称检索文本框，通过输入的关键词，来模糊查询匹配到的图片，以列表形式展示在检索栏下方。

查询页组件 `src/components/SearchPage.vue` 示例代码如下：

```vue
<template>
  <div>
    <h1>Search</h1>
    <form @submit.prevent="submit">
      <div>
        <label for="keyword">Keyword</label>
        <br />
        <input
          type="text"
          name="keyword"
          id="keyword"
          class="form-field"
          v-model="keyword"
        />
      </div>
      <div>
        <input type="submit" value="Search" />
      </div>
    </form>
    <div v-for="p of photos" :key="p.id" class="row">
      <div>
        <img :src="p.photoFile" />
      </div>
      <div>{{ p.name }}</div>
      <div>{{ p.description }}</div>
    </div>
  </div>
</template>

<script>
import axios from 'axios';
import { APIURL } from '../constant';

export default {
  name: 'SearchPage',
  data() {
    return {
      keyword: '',
      photos: [],
    };
  },
  methods: {
    submit() {
      this.$router.push({ path: '/search', query: { q: this.keyword } });
    },
    async search() {
      const { data: photos } = await axios.get(
        `${APIURL}/photos?name_like=${this.$route.query.q}`
      );
      this.photos = photos;
    },
  },
  watch: {
    $route: {
      immediate: true,
      handler() {
        this.keyword = this.$route.query.q;
        this.search();
      },
    },
  },
};
</script>

<style>
.form-field {
  width: 100%;
}
.row {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.row div {
  width: 25%;
}

.row img {
  width: 100px;
}
</style>
```

重点来看 `methods` 部分：

- `search` 方法通过 `axios` 发起 `GET` 请求到后台，然后将获取到的查询结果赋给响应式数组变量 `photos`。注意这里的查询参数是从 `URL` 来的，通过 `this.$route.query.q` 拿到。为什么不是 `this.keyword` 呢？因为表单提交方法 `submit` 的存在；
- `submit` 方法通过 `Vue Router` 跳转到 `/search` 路由，后期会配置成映射到当前 `SearchPage` 组件。也就是说，提交表单会提交到一个新的当前页面，并将页面中的查询关键词通过 `URL` 带到新页面，因此 `search` 方法的参数不能从新页面的文本框去获取（此时文本框的初始状态为空）。那么 search 方法是怎么触发的呢？通过观察 `this.$route` 的变化。
- `handler()` 方法的触发时间，是在提交了不同的关键词表单时触发的。一旦 `URL` 发生改变就会触发 `handler` 方法的执行。`handler` 完成两件事：
  - 将 URL 携带的上一页的查询关键词，赋给当前页被双向绑定的响应式变量 `keyword` 上，使得文本框内有相同的值；
  - 调用后端 `API` 接口执行具体查询；其实有了第 57 行的赋值操作，`search` 方法也能使用 `this.keyword` 来传参；既然本质上都是同一个值，何必要从 `this.keyword` 借道呢？
- `axios.get`：用于执行具体查询，请求地址中的查询参数为 `name_like`，是和演示使用的后端接口有关，是专有的写法，表示对 `name` 字段进行模糊匹配；
- `@submit.prevent`：表示提交表单时禁用默认行为，相当于执行了 `event.preventDefault()`；
- `immediate`：设为 `true` 后才能拿到最新的查询条件。通过观察 `this.$route` 可以拦截到 `URL` 的查询字符串 `query` 对象的变动情况；





